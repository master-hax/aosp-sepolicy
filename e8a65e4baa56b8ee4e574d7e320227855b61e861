{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6b4f8e8f_0d083361",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-11T06:57:34Z",
      "side": 1,
      "message": "Similarly, I thought this is needed otherwise an allow rule in vendor will always granted even if it actually violated our neverallow rule.",
      "range": {
        "startLine": 10,
        "startChar": 40,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b7c3238_b74e61cd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-11T06:57:34Z",
      "side": 1,
      "message": "Don\u0027t we need this in order to check if a neverallow rule in vendor is in conflict with our allow rule?",
      "range": {
        "startLine": 10,
        "startChar": 34,
        "endLine": 10,
        "endChar": 39
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3991b55_a306a6e4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-11T06:57:34Z",
      "side": 1,
      "message": "If both a type and attributes attached the type are public, then don\u0027t we need both? For example,\n\n// in platform/public/*\ntype foo;\nattribute foo_attr;\n\n// in platform/private/foo.te\ntypeattribute foo_attr foo;\n\n// in vendor\nallow foo_attr ...\n\nIf private/foo.te is missing when building vendor sepolicy, the allow rule will be a no-op (because no type is associated with foo_attr from the viewpoint of the vendor)?",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7db86c34_cb2c3c57",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-11T07:04:35Z",
      "side": 1,
      "message": "In the compiled vendor_sepolicy.cil, the rule will look like\n\n    (allow foo_attr (...))\n\nAnd in plat_sepolicy.cil there will be\n\n    (typeattribute foo foo_attr)\n\nWe combine all cil files (system, system_ext, product, vendor, odm) to build a binary policy file. So even in this case, vendor\u0027s foo_attr rule correctly affects foo.",
      "parentUuid": "c3991b55_a306a6e4",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2706b258_e333bed5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-11T07:04:35Z",
      "side": 1,
      "message": "It won\u0027t. In the build process, neverallow check is performed while combined sepolicy is built two times (on precompiled_sepolicy module and sepolicy_neverallows module), with all policy files (system + system_ext + product + vendor).",
      "parentUuid": "6b4f8e8f_0d083361",
      "range": {
        "startLine": 10,
        "startChar": 40,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b846136_dfff6966",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-11T07:04:35Z",
      "side": 1,
      "message": "Same as above.\n\nAlso, it will be vendor sepolicy\u0027s bug if it prohibits a rule defined under system/sepolicy.",
      "parentUuid": "6b7c3238_b74e61cd",
      "range": {
        "startLine": 10,
        "startChar": 34,
        "endLine": 10,
        "endChar": 39
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f786d48_9899d53d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2022-05-11T11:04:02Z",
      "side": 1,
      "message": "Although an older vendor image won\u0027t be checked against newer neverallow rules - which is good.",
      "parentUuid": "2706b258_e333bed5",
      "range": {
        "startLine": 10,
        "startChar": 40,
        "endLine": 10,
        "endChar": 50
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da3ac8f8_717f183f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2022-05-11T11:04:02Z",
      "side": 1,
      "message": "While I agree this is technically correct, I\u0027m slightly worried that this is taking things too far.\n\nI have a feeling that the private/public split should have 2 useful properties:\n1. Changes in private should not break vendor policy.\n2. Vendors shouldn\u0027t have to worry about what\u0027s in private.\n\nDoesn\u0027t that suggest that the association between a public type and a public attribute should normally be in public? A vendor rule could grant \u003cvendor domain\u003e access to \u003cpublic attribute\u003e on the assumption that they can then access the \u003cpublic domain\u003e.\n\nOne could even argue that any allow rules where both source and target are public should also be in public. Which is maybe taking things too far? I believe it\u0027s legitimate for a vendor to apply a public label, or at least some of them, to something vendor specific.\n\n(I think neverallows are less of an issue, since any breakage they cause is really obvious and probably desired.)\n\nThe question really is what exactly is the API.",
      "parentUuid": "7db86c34_cb2c3c57",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3097b7da_48f341d3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-11T11:47:47Z",
      "side": 1,
      "message": "\u003e The question really is what exactly is the API.\n\nI agree with this question and the points that Alan made. Anything (be it type association, or allow rule) on public entities (without private types involved) should better be public as well. I can\u0027t think of a reason to hide them from the user. When a type (or an attribute) is exposed as an API, we at least have to \"document\" what the type is for and what the type can do on other public types. Otherwise, vendors just wouldn\u0027t know how to extend and use the type and will have to look into the private policies anyway to learn.",
      "parentUuid": "da3ac8f8_717f183f",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e899a93_0cb59c9b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1561651
      },
      "writtenOn": "2022-05-12T00:48:57Z",
      "side": 1,
      "message": "\u003e  Anything (be it type association, or allow rule) on public entities (without private types involved) should better be public as well. \n\nThere is one counterexample to this (b/227803340 and ag/17630426). For mixed-build, if a rule is in the public part of the policy, it will trickle down to future releases. In this case, it is much harder to sunset an access than if the rule was in the private section.",
      "parentUuid": "3097b7da_48f341d3",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31efd251_f498e2f3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-12T01:14:42Z",
      "side": 1,
      "message": "\u003e \u003e The question really is what exactly is the API.\n\u003e I agree with this question and the points that Alan made. \n\nI think the definition is \"a set of types, attributes, macros, access vectors, etc.\". I don\u0027t think we should expose the implementation details (especially allow rules), just like we only expose method signatures for java APIs, or we only expose structures and function prototypes for C APIs.\n\nWe might want to expose type - attribute associations. However, what can we get from there? For example, I don\u0027t understand why vendors should take care of individual platform domains when using attributes like `netdomain`, or `appdomain`.\n\n\u003e I have a feeling that the private/public split should have 2 useful properties:\n\u003e 1. Changes in private should not break vendor policy.\n\u003e 2. Vendors shouldn\u0027t have to worry about what\u0027s in private.\n\nWe can\u0027t achieve 1 and 2 because of neverallow rules. We could move neverallow rules to public, but then we can\u0027t enforce private types. For example, if `foo` is defined under private, and if the platform wants to give access to `bar` only for `foo`, we should write\n\n    neverallow { domain -foo } bar:...\n    \nIMO, what we can get from private/public split is that..\n1) Vendors can\u0027t access random platform types.\n2) Private types don\u0027t need to be versioned, and can be changed independently.\n    \n\u003e I believe it\u0027s legitimate for a vendor to apply a public label, or at least some of them, to something vendor specific.\n\nSorry I don\u0027t get this. Could you elaborate?\n\n\u003e Anything (be it type association, or allow rule) on public entities (without private types involved) should better be public as well. I can\u0027t think of a reason to hide them from the user.\n\nI think we should tackle the private\u003c-\u003epublic split from the build system aspect. \n\n\u003e When a type (or an attribute) is exposed as an API, we at least have to \"document\" what the type is for and what the type can do on other public types.\n\nDocumentation is always good. +1\n\n\u003e Otherwise, vendors just wouldn\u0027t know how to extend and use the type and will have to look into the private policies anyway to learn.\n\nI think this is more of a documentation problem, rather than public\u003c-\u003eprivate problem.",
      "parentUuid": "3097b7da_48f341d3",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2e4e35e_f169fa8c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-12T06:52:01Z",
      "side": 1,
      "message": "Thiébaud, \n\nI don\u0027t think the CL makes it harder or easier to sunset the bind access. You can drop it when the platform no longer requires bind access. Vendors wouldn\u0027t be affected as long as they have been implicitly using the access via platform-provided libraries. You may ask what if they are explicitly using the access. Well, such a case could happen even when the access was made in the private section, right? I think it\u0027s out of scope of sepolicy.\n\nInseob,\n\n\u003e we only expose structures and function prototypes for C APIs.\n\nWhat the function does, and pre/post conditions are also part of the APIs.\n\n\u003e\u003e I believe it\u0027s legitimate for a vendor to apply a public label, or at least some of them, to something vendor specific.\n\n\u003e Sorry I don\u0027t get this. Could you elaborate?\n\nConsider this case. Platform defines an attribute and rules around the attribute. Vendor uses typeattribute command to associate one of its domain to the attribute, inheriting all the rules as well. This is just like the (public) member functions of the class you are inheriting from are all APIs; the name of the parent class is not only the API.",
      "parentUuid": "31efd251_f498e2f3",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5febf89_94fa35e2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-12T09:58:43Z",
      "side": 1,
      "message": "\u003e What the function does, and pre/post conditions are also part of the APIs.\n\nI think this is more of a documentation problem.\n\n\u003e This is just like the (public) member functions of the class you are inheriting from are all APIs; the name of the parent class is not only the API.\n\nI got it. However, what\u0027s different between placing rules under public and private?",
      "parentUuid": "f2e4e35e_f169fa8c",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3604e261_03567a70",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2022-05-12T12:25:09Z",
      "side": 1,
      "message": "\u003e We can\u0027t achieve 1 and 2 because of neverallow rules\n\nI don\u0027t think that\u0027s true. Note I said \"I think neverallows are less of an issue, since any breakage they cause is really obvious and probably desired.\" \n\nOld vendor policy doesn\u0027t have new neverallows applied to it, so accidental breakage is less likely; we know adding a neverallow can always break things and so we tend to only do it deliberately; and a neverallow change is never silently breaking - it fails at build time. That\u0027s not true if we remove an allow on an attribute, say - it may break some obscure functionality that isn\u0027t well tested.\n\nFor allow rules: documenting the purpose/contract of a type or attribute, where it is available for vendor use, does sound really important. It is not at all clear to me when it is best to have the allows public and when private.",
      "parentUuid": "a5febf89_94fa35e2",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20a611a2_bd5cd882",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-13T05:51:48Z",
      "side": 1,
      "message": "Thiébaud let me know that if we have an allow rule in public, that is compiled into the vendor sepolicy, which makes it difficult for us to alter (or remove) the allow rule in the future. I think this very much makes sense.\n\nHowever, in some cases, that may be the case we want. We want an allow rule to persist in the old vendor policy even if the rule is disappeared in a future platform policy. I guess this will be the case when the allow rule is originated from a VNDK (or vendor_available: true, or vendor: true) library.\n\nSo I think the answer to the private v.s. public question is actually about whether an allow rule or a type-attribute association is originated from platform or not (i.e. VNDK or vendor-owned). The former goes to private, and the latter goes to public.\n\nI feel like the names public and private don\u0027t reflect their true nature, so I suggest a name change.\n\n* public -\u003e shared\n* private -\u003e platform (or system)",
      "parentUuid": "3604e261_03567a70",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93a14376_aaecf41e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2024-03-27T08:21:03Z",
      "side": 1,
      "message": "closing old thread.",
      "parentUuid": "20a611a2_bd5cd882",
      "range": {
        "startLine": 10,
        "startChar": 51,
        "endLine": 10,
        "endChar": 65
      },
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af474c9a_2f82cea6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1291338
      },
      "writtenOn": "2022-05-11T04:04:46Z",
      "side": 1,
      "message": "This is still WIP; we have plenty of files to refactor. However, PTAL. Does this look good?",
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5eb23a8f_66803577",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2022-05-11T07:12:47Z",
      "side": 1,
      "message": "Thanks for the answers. Then I have no concern. I believe that all changes here are just moving things around. This change is great.",
      "revId": "e8a65e4baa56b8ee4e574d7e320227855b61e861",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}